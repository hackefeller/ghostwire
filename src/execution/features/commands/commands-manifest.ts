// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by src/script/build-commands-manifest.ts
// Run 'bun run src/script/build-commands-manifest.ts' to regenerate

import type { CommandDefinition } from "../claude-code-command-loader";

export type CommandManifestEntry = {
  name: string;
  command: Omit<CommandDefinition, "name">;
};

export const COMMANDS_MANIFEST: ReadonlyArray<CommandManifestEntry> = [
  {
    name: "ghostwire:code:format",
    command: {
      description: "Apply consistent formatting and style standards",
      template:
        "\n# Code:Format Command\nApply consistent formatting and style standards across codebase.\n## Process\n1. **Config Review** - Verify formatting rules (prettier, eslint, rustfmt, etc.)\n2. **Apply Formatter** - Run format tools across specified scope\n3. **Review Changes** - Check formatted output for correctness\n4. **Commit** - Create formatting-only commit with clear message\n5. **Update CI** - Ensure formatting checks pass\n## Features\n- Batch format multiple files or entire directories\n- Apply language-specific formatters\n- Integrate with pre-commit hooks\n- Generate formatting-only commits for clean history\n## Rules\n- Formatting changes should be separate from functional changes\n- Always get team consensus on formatting rules before bulk formatting\n- Don't mix formatting with functional changes\n<format-scope>\n$ARGUMENTS\n</format-scope>\n",
      argumentHint: "[path-to-format] [--dry-run]",
    },
  },
  {
    name: "ghostwire:code:optimize",
    command: {
      description: "Improve performance, reduce bundle size, or enhance efficiency",
      template:
        '\n# Code:Optimize Command\nImprove performance, reduce bundle size, or enhance runtime efficiency.\n## Optimization Areas\n- **Algorithmic** - Better algorithms and data structures\n- **Memory** - Reduce allocations and improve garbage collection\n- **CPU** - Cache-friendly code, vectorization\n- **Network** - Reduce requests, optimize payload sizes\n- **Build** - Faster compilation and bundling\n- **Runtime** - Lazy loading, code splitting\n## Key Profiles & Tasks\n- Use profile `oracle_performance` via delegate_task(subagent_type="do")\n- Measure performance before and after optimizations\n- Profile code to identify actual bottlenecks\n- Prioritize high-impact optimizations\n- Ensure optimizations don\'t harm readability\n## Verification\n- Benchmark improvements with concrete metrics\n- Run full test suite\n- Check production-like environment behavior\n- Monitor for regressions\n<optimization-target>\n$ARGUMENTS\n</optimization-target>\n',
      argumentHint: "[target] [--area=algorithmic|memory|cpu|network|build]",
    },
  },
  {
    name: "ghostwire:code:refactor",
    command: {
      description: "Systematically refactor code while maintaining functionality",
      template:
        '\n# Code:Refactor Command\nSystematically refactor code while maintaining functionality and improving clarity, performance, or maintainability.\n## Process\n1. **Scope Analysis** - Define refactoring boundaries (file, module, or project level)\n2. **Impact Assessment** - Identify affected code, tests, and dependencies\n3. **Strategy Selection** - Choose approach (safe vs aggressive, incremental vs comprehensive)\n4. **Refactoring Execution** - Apply transformations using code transformation tools\n5. **Verification** - Run tests and validate functionality\n6. **Documentation** - Update comments and related documentation\n## Key Profiles & Tasks\n- Use profile `reviewer_typescript` via delegate_task(subagent_type="do")\n- Use profile `reviewer_python` via delegate_task(subagent_type="do")\n- Use profile `reviewer_simplicity` via delegate_task(subagent_type="do")\n- Use profile `analyzer_patterns` via delegate_task(subagent_type="do")\n- Run comprehensive test suites before/after refactoring\n## Refactoring Types\n- **Extract Method** - Break large functions into smaller, focused units\n- **Rename** - Improve code clarity through better naming\n- **Inline** - Remove unnecessary abstraction layers\n- **Move** - Reorganize code for better structure\n- **Simplify** - Remove duplication and complexity\n- **Performance** - Optimize without changing behavior\n<refactoring-target>\n$ARGUMENTS\n</refactoring-target>\n',
      argumentHint: "<target> [--scope=file|module|project] [--strategy=safe|aggressive]",
    },
  },
  {
    name: "ghostwire:code:review",
    command: {
      description: "Conduct comprehensive code reviews with specialist agents",
      template:
        '\n# Code:Review Command\nConduct comprehensive code reviews leveraging multiple specialist agents.\n## Review Types\n- **Architecture Review** - High-level design and patterns\n- **Security Review** - Vulnerability and security best practices\n- **Performance Review** - Optimization opportunities\n- **Style Review** - Code quality and consistency\n- **Complexity Review** - Simplification opportunities\n- **Test Coverage Review** - Testing strategy adequacy\n## Key Profiles & Tasks\n- Use profile `reviewer_rails` via delegate_task(subagent_type="do")\n- Use profile `reviewer_python` via delegate_task(subagent_type="do")\n- Use profile `reviewer_typescript` via delegate_task(subagent_type="do")\n- Use profile `reviewer_rails_dh` via delegate_task(subagent_type="do")\n- Use profile `reviewer_security` via delegate_task(subagent_type="do")\n- Use profile `oracle_performance` via delegate_task(subagent_type="do")\n- Use profile `reviewer_simplicity` via delegate_task(subagent_type="do")\n## Output\n- Structured review comments\n- Priority-ordered issues\n- Actionable suggestions\n- References to relevant patterns or best practices\n<code-context>\n$ARGUMENTS\n</code-context>\n',
      argumentHint: "[file-path or PR-number] [--type=architecture|security|performance]",
    },
  },
  {
    name: "ghostwire:docs:deploy-docs",
    command: {
      description: "Build and deploy documentation to hosting",
      template:
        "\n# Docs:Deploy-Docs Command\nBuild and deploy documentation to live hosting platform.\n## Process\n1. **Build Documentation** - Generate HTML/static content from sources\n2. **Link Validation** - Verify all internal and external links\n3. **Search Indexing** - Build search indexes for documentation\n4. **Environment Setup** - Configure deployment target\n5. **Deployment** - Upload to hosting platform\n6. **Verification** - Verify deployed docs are accessible\n7. **Notification** - Announce deployment to team\n## Documentation Formats Supported\n- **Markdown** - Static markdown-based docs\n- **API Docs** - Generated from OpenAPI/GraphQL specs\n- **Docusaurus** - React-based documentation site\n- **MkDocs** - Python-based documentation\n- **Sphinx** - Python documentation generator\n- **Jekyll** - Static site generator\n## Deployment Targets\n- **GitHub Pages** - Free hosted on GitHub\n- **Vercel** - Automatic deployments\n- **Netlify** - Continuous deployment\n- **AWS S3/CloudFront** - Custom hosting\n- **Self-Hosted** - Custom server\n<docs-context>\n$ARGUMENTS\n</docs-context>\n",
      argumentHint: "[--target=github-pages|vercel|netlify|s3] [--version=latest|stable]",
    },
  },
  {
    name: "ghostwire:docs:feature-video",
    command: {
      description: "Create demonstration video for feature",
      template:
        "\n# Docs:Feature-Video Command\nCreate demonstration video for new feature or capability.\n## Video Production Process\n1. **Script Writing** - Write clear, concise demo script\n2. **Environment Setup** - Prepare for recording\n3. **Recording** - Record feature demonstration\n4. **Editing** - Edit for clarity and pacing\n5. **Captioning** - Add captions for accessibility\n6. **Hosting** - Upload to video platform\n7. **Documentation** - Embed in documentation\n8. **Publishing** - Publish to channels\n## Video Types\n- **Feature Demo** - Walkthrough of new feature\n- **Tutorial** - Step-by-step usage guide\n- **Comparison** - Before/after comparison\n- **Quick Tip** - Brief optimization techniques\n- **Troubleshooting** - Common issues and solutions\n## Platforms\n- **YouTube** - Public video hosting\n- **Vimeo** - Professional video hosting\n- **Docs Site** - Embedded in documentation\n- **Social Media** - Short clips for marketing\n- **Internal** - Private videos for team\n<video-context>\n$ARGUMENTS\n</video-context>\n",
      argumentHint: "[feature-name] [--type=demo|tutorial|comparison|tip]",
    },
  },
  {
    name: "ghostwire:docs:release-docs",
    command: {
      description: "Create versioned documentation release",
      template:
        "\n# Docs:Release-Docs Command\nCreate versioned documentation release for new software version.\n## Process\n1. **Documentation Audit** - Verify docs match software version\n2. **Version Creation** - Create new version branch/directory\n3. **Content Review** - Ensure completeness and accuracy\n4. **Breaking Changes** - Document any breaking changes clearly\n5. **Migration Guides** - Create guides for upgrade path\n6. **Release Notes** - Generate release notes from commits\n7. **Deployment** - Deploy versioned documentation\n8. **Announcement** - Publish release announcement\n## Features\n- Archive previous versions\n- Version selector in docs UI\n- Compatibility matrix display\n- Changelog generation\n- Migration guide generation\n- SEO optimization for versioned content\n<release-context>\n$ARGUMENTS\n</release-context>\n",
      argumentHint: "[version] [--create-migration-guide]",
    },
  },
  {
    name: "ghostwire:docs:test-browser",
    command: {
      description: "Test documentation in browser environment",
      template:
        "\n# Docs:Test-Browser Command\nTest documentation in actual browser environment for functionality and rendering.\n## Testing Scope\n- **Rendering** - Verify HTML/CSS renders correctly\n- **Responsiveness** - Check mobile, tablet, desktop views\n- **Interactivity** - Test any interactive elements\n- **Code Examples** - Run and verify code samples work\n- **Links** - Validate all links are functional\n- **Search** - Test search functionality\n- **Accessibility** - Check WCAG compliance\n- **Performance** - Measure load times and responsiveness\n## Browser Coverage\n- Chrome/Chromium (latest)\n- Firefox (latest)\n- Safari (latest)\n- Edge (latest)\n- Mobile browsers (iOS Safari, Chrome Mobile)\n## Test Types\n- **Visual Regression** - Compare screenshots to baseline\n- **Functional** - Test interactive components\n- **Integration** - Test links between docs and external sites\n- **Accessibility** - Screen reader compatibility, keyboard navigation\n- **SEO** - Meta tags, structured data\n<test-context>\n$ARGUMENTS\n</test-context>\n",
      argumentHint:
        "[--browsers=chrome,firefox,safari] [--test-types=visual,functional,accessibility]",
    },
  },
  {
    name: "ghostwire:git:branch",
    command: {
      description: "Create and manage feature branches with naming conventions",
      template:
        "\n# Git:Branch Command\nCreate and manage feature branches following project naming conventions.\n## Process\n1. **Branch Planning** - Understand the feature or fix\n2. **Name Generation** - Create conventional branch name\n3. **Base Selection** - Choose appropriate base branch\n4. **Branch Creation** - Create and switch to new branch\n5. **Setup** - Configure tracking and any branch-specific settings\n## Branch Naming\nFollows convention: `<type>/<scope>-<description>`\n- **type:** feature, fix, refactor, docs, test\n- **scope:** Module or component affected\n- **description:** Kebab-case, concise description\nExamples:\n- `feature/auth-jwt-validation`\n- `fix/cart-total-calculation`\n- `refactor/api-response-handler`\n## Features\n- Delete local and remote branches\n- Rename branches safely\n- Track remote branches\n- List branches with filtering\n- Cleanup stale branches\n<branch-context>\n$ARGUMENTS\n</branch-context>\n",
      argumentHint: "[feature-description] [--type=feature|fix|refactor]",
    },
  },
  {
    name: "ghostwire:git:cleanup",
    command: {
      description: "Remove stale branches and optimize repository",
      template:
        "\n# Git:Cleanup Command\nRemove stale branches and optimize repository state.\n## Process\n1. **Branch Analysis** - Identify candidates for cleanup\n2. **Safety Verification** - Ensure branches are merged upstream\n3. **Remote Cleanup** - Delete remote branches\n4. **Local Cleanup** - Delete local branches\n5. **Repository Maintenance** - Optimize repository\n## Features\n- Remove merged branches locally and remotely\n- Prune remote-tracking branches\n- Clean up stale branches older than N days\n- Safe deletion with confirmation\n- Generate cleanup report\n## Safety\n- Never delete branches without confirmation\n- Verify branches are merged before deletion\n- Preserve main/master and release branches\n- Maintain branch history for reference\n<cleanup-options>\n$ARGUMENTS\n</cleanup-options>\n",
      argumentHint: "[--days=N] [--dry-run]",
    },
  },
  {
    name: "ghostwire:git:merge",
    command: {
      description: "Merge branches safely with conflict resolution",
      template:
        "\n# Git:Merge Command\nMerge branches safely with conflict resolution and validation.\n## Process\n1. **Pre-Merge Validation** - Check branch state and conflicts\n2. **Conflict Detection** - Identify merge conflicts early\n3. **Merge Strategy** - Choose appropriate merge approach\n4. **Conflict Resolution** - Resolve conflicts systematically\n5. **Post-Merge Verification** - Validate tests and functionality\n## Merge Strategies\n- **Fast-Forward** - Clean linear history when possible\n- **Squash** - Combine commits into single logical unit\n- **Rebase** - Rebase branch for clean history\n- **Three-Way** - Standard merge with conflict resolution\n## Features\n- Automatic conflict detection\n- Interactive conflict resolution\n- Run tests before merge\n- Preserve commit history\n- Rollback on validation failure\n<merge-context>\n$ARGUMENTS\n</merge-context>\n",
      argumentHint: "[branch-name] [--strategy=fast-forward|squash|rebase]",
    },
  },
  {
    name: "ghostwire:git:smart-commit",
    command: {
      description: "Generate well-structured commits following conventions",
      template:
        "\n# Git:Smart-Commit Command\nGenerate well-structured commits that follow project conventions and tell a clear story.\n## Process\n1. **Stage Review** - Understand what changes are staged\n2. **Change Analysis** - Categorize changes (feature, fix, refactor, test, docs)\n3. **Conventional Commit** - Generate commit message following conventional commits\n4. **Message Validation** - Ensure message clarity and completeness\n5. **Commit Creation** - Create the commit with proper formatting\n## Commit Format\nUses Conventional Commits standard:\n```\n<type>(<scope>): <subject>\n<body>\n<footer>\n```\n- **type:** feat, fix, refactor, test, docs, chore, perf, ci\n- **scope:** Affected module or component\n- **subject:** Clear, imperative description (max 50 chars)\n- **body:** Detailed explanation of what and why (max 72 chars per line)\n- **footer:** References and breaking changes\n## Key Features\n- Detects commit type from code changes\n- Validates message against project conventions\n- References related issues\n- Notes breaking changes when applicable\n- Provides commit history coherence\n<commit-context>\n$ARGUMENTS\n</commit-context>\n",
      argumentHint: '[--message="custom message"]',
    },
  },
  {
    name: "ghostwire:lint:ruby",
    command: {
      description: "Run linting and code quality checks on Ruby and ERB files",
      template:
        '\n# Lint:Ruby Command\nRun linting and code quality checks on Ruby and ERB files. Run before pushing to origin.\n## Linters\n### Ruby - StandardRB\nCheck Ruby code style:\n```bash\nbundle exec standardrb\n```\nAuto-fix Ruby style issues:\n```bash\nbundle exec standardrb --fix\n```\n### ERB - ERBLint\nCheck ERB templates:\n```bash\nbundle exec erblint --lint-all\n```\nAuto-fix ERB issues:\n```bash\nbundle exec erblint --lint-all --autocorrect\n```\n### Security - Brakeman\nCheck for security vulnerabilities:\n```bash\nbin/brakeman\n```\n## Workflow\n1. **Initial Assessment**: Determine which checks are needed based on the files changed or the specific request\n2. **Execute Appropriate Tools**: Run the appropriate linters based on file types\n3. **Analyze Results**: Parse tool outputs to identify patterns and prioritize issues\n4. **Take Action**: Commit fixes with `style: linting`\n## File Types\n- **.rb files**: Use StandardRB\n- **.erb files**: Use ERBLint\n- **Security check**: Use Brakeman\n## Usage\nRun all checks:\n```bash\nbundle exec standardrb && bundle exec erblint --lint-all && bin/brakeman\n```\nAuto-fix and commit:\n```bash\nbundle exec standardrb --fix\nbundle exec erblint --lint-all --autocorrect\ngit add -A\ngit commit -m "style: linting fixes"\n```\n<user-request>\n$ARGUMENTS\n</user-request>',
      argumentHint: "[file-path or --all]",
    },
  },
  {
    name: "ghostwire:project:build",
    command: {
      description: "Compile, transpile, and bundle project code",
      template:
        "\n# Project:Build Command\nCompile, transpile, and bundle project code for distribution.\n## Process\n1. **Build Configuration Review** - Understand build setup\n2. **Dependency Verification** - Ensure all dependencies installed\n3. **Build Execution** - Run build process\n4. **Output Verification** - Validate build artifacts\n5. **Artifact Organization** - Organize outputs by platform/variant\n## Build Types\n- **Development** - Fast rebuilds with source maps\n- **Production** - Optimized, minified output\n- **Staging** - Production-like with debug capabilities\n- **Test** - Instrumented for coverage\n## Features\n- Parallel builds for speed\n- Incremental rebuilds (only changed files)\n- Multiple output formats (ESM, CommonJS, UMD, etc.)\n- Platform-specific builds\n- Asset optimization\n- Type checking integration\n<build-context>\n$ARGUMENTS\n</build-context>\n",
      argumentHint: "[--mode=development|production|staging]",
    },
  },
  {
    name: "ghostwire:project:constitution",
    command: {
      description: "Create or update project constitution with core principles",
      template:
        '\n---\ndescription: "Project constitution with core principles and governance rules"\n---\n# $PROJECT_NAME Constitution\n**Version**: $VERSION | **Ratified**: $DATE | **Last Amended**: $DATE\n---\n## Core Principles\n### I. $PRINCIPLE_1_NAME\n$PRINCIPLE_1_DESCRIPTION\n### II. $PRINCIPLE_2_NAME\n$PRINCIPLE_2_DESCRIPTION\n### III. $PRINCIPLE_3_NAME\n$PRINCIPLE_3_DESCRIPTION\n### IV. $PRINCIPLE_4_NAME\n$PRINCIPLE_4_DESCRIPTION\n### V. $PRINCIPLE_5_NAME\n$PRINCIPLE_5_DESCRIPTION\n',
      argumentHint: "[project name] (optional, defaults to repo name)",
    },
  },
  {
    name: "ghostwire:project:deploy",
    command: {
      description: "Deploy project to specified environment",
      template:
        "\n# Project:Deploy Command\nDeploy project to specified environment (staging, production, etc.).\n## Process\n1. **Build Verification** - Ensure successful build\n2. **Environment Validation** - Verify target environment configuration\n3. **Dependency Preparation** - Install/update all dependencies\n4. **Migration Execution** - Run any database migrations\n5. **Deployment** - Deploy to target environment\n6. **Health Checks** - Verify deployment health\n7. **Rollback Plan** - Prepare rollback if needed\n## Deployment Targets\n- **Development** - Local or dev server\n- **Staging** - Pre-production testing environment\n- **Production** - Public-facing environment\n- **Multiple Regions** - Distributed deployment\n## Features\n- Blue-green deployments\n- Canary deployments\n- Zero-downtime updates\n- Automatic rollback on failure\n- Health check monitoring\n- Deployment notifications\n## Safety\n- Always test deployments in staging first\n- Use feature flags for risky changes\n- Monitor logs and metrics after deployment\n- Have rollback procedure ready\n- Get approval for production deployments\n<deploy-context>\n$ARGUMENTS\n</deploy-context>\n",
      argumentHint: "[environment] [--strategy=blue-green|canary|standard]",
    },
  },
  {
    name: "ghostwire:project:init",
    command: {
      description: "Initialize new project with structure and tooling",
      template:
        "\n# Project:Init Command\nInitialize a new project with proper structure, configuration, and development tooling.\n## Process\n1. **Project Analysis** - Understand project type and requirements\n2. **Template Selection** - Choose appropriate starter template\n3. **Structure Creation** - Set up directory structure\n4. **Config Setup** - Initialize configuration files (package.json, tsconfig, etc.)\n5. **Tooling Setup** - Configure linting, testing, formatting\n6. **Documentation** - Create README and contributing guides\n7. **VCS Setup** - Initialize git and create initial commit\n## Project Types\n- **Web Application** - React, Vue, Angular, Next.js, etc.\n- **API Server** - Express, Rails, FastAPI, etc.\n- **Library** - TypeScript, Python, Ruby gem, etc.\n- **CLI Tool** - Command-line utility\n- **Monorepo** - Multi-package repository\n## Key Features\n- Choose language and framework\n- Configure package manager (npm, bun, pip, cargo)\n- Setup testing framework (Jest, pytest, RSpec)\n- Configure linting (ESLint, Pylint, RuboCop)\n- Setup formatting (Prettier, Black, RuboCop)\n- Create git workflow templates\n- Generate GitHub Actions workflows\n<project-context>\n$ARGUMENTS\n</project-context>\n",
      argumentHint: "[project-name] [--type=web|api|library|cli|monorepo]",
    },
  },
  {
    name: "ghostwire:project:map",
    command: {
      description: "Map project structure and generate hierarchical AGENTS.md knowledge base",
      template:
        '\n# /init-deep\nGenerate hierarchical AGENTS.md files. Root + complexity-scored subdirectories.\n## Usage\n```\n/init-deep                      # Update mode: modify existing + create new where warranted\n/init-deep --create-new         # Read existing → remove all → regenerate from scratch\n/init-deep --max-depth=2        # Limit directory depth (default: 3)\n```\n---\n## Workflow (High-Level)\n1. **Discovery + Analysis** (concurrent)\n   - Fire background profile.researcher_codebase agents immediately\n   - Main session: bash structure + LSP codemap + read existing AGENTS.md\n2. **Score & Decide** - Determine AGENTS.md locations from merged findings\n3. **Generate** - Root first, then subdirs in parallel\n4. **Review** - Deduplicate, trim, validate\n<critical>\n**TodoWrite ALL phases. Mark in_progress → completed in real-time.**\n```\nTodoWrite([\n  { id: "discovery", content: "Fire profile.researcher_codebase agents + LSP codemap + read existing", status: "pending", priority: "high" },\n  { id: "scoring", content: "Score directories, determine locations", status: "pending", priority: "high" },\n  { id: "generate", content: "Generate AGENTS.md files (root + subdirs)", status: "pending", priority: "high" },\n  { id: "review", content: "Deduplicate, validate, trim", status: "pending", priority: "medium" }\n])\n```\n</critical>\n',
      argumentHint: "[--create-new] [--max-depth=N]",
    },
  },
  {
    name: "ghostwire:refactor",
    command: {
      description:
        "Intelligent refactoring command with LSP, AST-grep, architecture analysis, codemap, and TDD verification",
      template:
        '\n# Intelligent Refactor Command\n## Usage\n```\n/refactor <refactoring-target> [--scope=<file|module|project>] [--strategy=<safe|aggressive>]\nArguments:\n  refactoring-target: What to refactor. Can be:\n    - File path: src/auth/handler.ts\n    - Symbol name: "AuthService class"\n    - Pattern: "all functions using deprecated API"\n    - Description: "extract validation logic into separate module"\nOptions:\n  --scope: Refactoring scope (default: module)\n    - file: Single file only\n    - module: Module/directory scope\n    - project: Entire codebase\n  --strategy: Risk tolerance (default: safe)\n    - safe: Conservative, maximum test coverage required\n    - aggressive: Allow broader changes with adequate coverage\n```\n## What This Command Does\nPerforms intelligent, deterministic refactoring with full codebase awareness. Unlike blind search-and-replace, this command:\n1. **Understands your intent** - Analyzes what you actually want to achieve\n2. **Maps the codebase** - Builds a definitive codemap before touching anything\n3. **Assesses risk** - Evaluates test coverage and determines verification strategy\n4. **Plans meticulously** - Creates a detailed plan with Plan agent\n5. **Executes precisely** - Step-by-step refactoring with LSP and AST-grep\n6. **Verifies constantly** - Runs tests after each change to ensure zero regression\n---\n# PHASE 0: INTENT GATE (MANDATORY FIRST STEP)\n**BEFORE ANY ACTION, classify and validate the request.**\n## Step 0.1: Parse Request Type\n| Signal | Classification | Action |\n|--------|----------------|--------|\n| Specific file/symbol | Explicit | Proceed to codebase analysis |\n| "Refactor X to Y" | Clear transformation | Proceed to codebase analysis |\n| "Improve", "Clean up" | Open-ended | **MUST ask**: "What specific improvement?" |\n| Ambiguous scope | Uncertain | **MUST ask**: "Which modules/files?" |\n| Missing context | Incomplete | **MUST ask**: "What\'s the desired outcome?" |\n## Step 0.2: Validate Understanding\nBefore proceeding, confirm:\n- [ ] Target is clearly identified\n- [ ] Desired outcome is understood\n- [ ] Scope is defined (file/module/project)\n- [ ] Success criteria can be articulated\n**If ANY of above is unclear, ASK CLARIFYING QUESTION:**\n```\nI want to make sure I understand the refactoring goal correctly.\n**What I understood**: [interpretation]\n**What I\'m unsure about**: [specific ambiguity]\nOptions I see:\n1. [Option A] - [implications]\n2. [Option B] - [implications]\n**My recommendation**: [suggestion with reasoning]\nShould I proceed with [recommendation], or would you prefer differently?\n```\n## Step 0.3: Create Initial Todos\n**IMMEDIATELY after understanding the request, create todos:**\n```\nTodoWrite([\n  {"id": "phase-1", "content": "PHASE 1: Codebase Analysis - launch parallel profile.researcher_codebase agents", "status": "pending", "priority": "high"},\n  {"id": "phase-2", "content": "PHASE 2: Build Codemap - map dependencies and impact zones", "status": "pending", "priority": "high"},\n  {"id": "phase-3", "content": "PHASE 3: Test Assessment - analyze test coverage and verification strategy", "status": "pending", "priority": "high"},\n  {"id": "phase-4", "content": "PHASE 4: Plan Generation - invoke Plan agent for detailed refactoring plan", "status": "pending", "priority": "high"},\n  {"id": "phase-5", "content": "PHASE 5: Execute Refactoring - step-by-step with continuous verification", "status": "pending", "priority": "high"},\n  {"id": "phase-6", "content": "PHASE 6: Final Verification - full test suite and regression check", "status": "pending", "priority": "high"}\n])\n```\n---\n# PHASE 1: CODEBASE ANALYSIS (PARALLEL EXPLORATION)\n**Mark phase-1 as in_progress.**\n## 1.1: Launch Parallel Scout Recon Agents (BACKGROUND)\nFire ALL of these simultaneously using `delegate_task`:\n```\n// Agent 1: Find the refactoring target\ndelegate_task(\n  subagent_type="research",\n  run_in_background=true,\n  prompt="Find all occurrences and definitions of [TARGET]. \n  Report: file paths, line numbers, usage patterns."\n)\n// Agent 2: Find related code\ndelegate_task(\n  subagent_type="research", \n  run_in_background=true,\n  prompt="Find all code that imports, uses, or depends on [TARGET].\n  Report: dependency chains, import graphs."\n)\n// Agent 3: Find similar patterns\ndelegate_task(\n  subagent_type="research",\n  run_in_background=true,\n  prompt="Find similar code patterns to [TARGET] in the codebase.\n  Report: analogous implementations, established conventions."\n)\n// Agent 4: Find tests\ndelegate_task(\n  subagent_type="research",\n  run_in_background=true,\n  prompt="Find all test files related to [TARGET].\n  Report: test file paths, test case names, coverage indicators."\n)\n// Agent 5: Architecture context\ndelegate_task(\n  subagent_type="research",\n  run_in_background=true,\n  prompt="Find architectural patterns and module organization around [TARGET].\n  Report: module boundaries, layer structure, design patterns in use."\n)\n```\n## 1.2: Direct Tool Exploration (WHILE AGENTS RUN)\nWhile background agents are running, use direct tools:\n### LSP Tools for Precise Analysis:\n```typescript\n// Find definition(s)\nLspGotoDefinition(filePath, line, character)  // Where is it defined?\n// Find ALL usages across workspace\nLspFindReferences(filePath, line, character, includeDeclaration=true)\n// Get file structure\nLspDocumentSymbols(filePath)  // Hierarchical outline\nLspWorkspaceSymbols(filePath, query="[target_symbol]")  // Search by name\n// Get current diagnostics\nlsp_diagnostics(filePath)  // Errors, warnings before we start\n```\n### AST-Grep for Pattern Analysis:\n```typescript\n// Find structural patterns\nast_grep_search(\n  pattern="function $NAME($$$) { $$$ }",  // or relevant pattern\n  lang="typescript",  // or relevant language\n  paths=["src/"]\n)\n// Preview refactoring (DRY RUN)\nast_grep_replace(\n  pattern="[old_pattern]",\n  rewrite="[new_pattern]",\n  lang="[language]",\n  dryRun=true  // ALWAYS preview first\n)\n```\n### Grep for Text Patterns:\n```\ngrep(pattern="[search_term]", path="src/", include="*.ts")\n```\n## 1.3: Collect Background Results\n```\nbackground_output(task_id="[agent_1_id]")\nbackground_output(task_id="[agent_2_id]")\n...\n```\n**Mark phase-1 as completed after all results collected.**\n---\n# PHASE 2: BUILD CODEMAP (DEPENDENCY MAPPING)\n**Mark phase-2 as in_progress.**\n## 2.1: Construct Definitive Codemap\nBased on Phase 1 results, build:\n```\n## CODEMAP: [TARGET]\n### Core Files (Direct Impact)\n- `path/to/file.ts:L10-L50` - Primary definition\n- `path/to/file2.ts:L25` - Key usage\n### Dependency Graph\n```\n[TARGET] \n├── imports from: \n│   ├── module-a (types)\n│   └── module-b (utils)\n├── imported by:\n│   ├── consumer-1.ts\n│   ├── consumer-2.ts\n│   └── consumer-3.ts\n└── used by:\n    ├── handler.ts (direct call)\n    └── service.ts (dependency injection)\n```\n### Impact Zones\n| Zone | Risk Level | Files Affected | Test Coverage |\n|------|------------|----------------|---------------|\n| Core | HIGH | 3 files | 85% covered |\n| Consumers | MEDIUM | 8 files | 70% covered |\n| Edge | LOW | 2 files | 50% covered |\n### Established Patterns\n- Pattern A: [description] - used in N places\n- Pattern B: [description] - established convention\n```\n## 2.2: Identify Refactoring Constraints\nBased on codemap:\n- **MUST follow**: [existing patterns identified]\n- **MUST NOT break**: [critical dependencies]\n- **Safe to change**: [isolated code zones]\n- **Requires migration**: [breaking changes impact]\n**Mark phase-2 as completed.**\n---\n# PHASE 3: TEST ASSESSMENT (VERIFICATION STRATEGY)\n**Mark phase-3 as in_progress.**\n## 3.1: Detect Test Infrastructure\n```bash\n# Check for test commands\ncat package.json | jq \'.scripts | keys[] | select(test("test"))\'\n# Or for Python\nls -la pytest.ini pyproject.toml setup.cfg\n# Or for Go\nls -la *_test.go\n```\n## 3.2: Analyze Test Coverage\n```\n// Find all tests related to target\ndelegate_task(\n  subagent_type="research",\n  run_in_background=false,  // Need this synchronously\n  prompt="Analyze test coverage for [TARGET]:\n  1. Which test files cover this code?\n  2. What test cases exist?\n  3. Are there integration tests?\n  4. What edge cases are tested?\n  5. Estimated coverage percentage?"\n)\n```\n## 3.3: Determine Verification Strategy\nBased on test analysis:\n| Coverage Level | Strategy |\n|----------------|----------|\n| HIGH (>80%) | Run existing tests after each step |\n| MEDIUM (50-80%) | Run tests + add safety assertions |\n| LOW (<50%) | **PAUSE**: Propose adding tests first |\n| NONE | **BLOCK**: Refuse aggressive refactoring |\n**If coverage is LOW or NONE, ask user:**\n```\nTest coverage for [TARGET] is [LEVEL].\n**Risk Assessment**: Refactoring without adequate tests is dangerous.\nOptions:\n1. Add tests first, then refactor (RECOMMENDED)\n2. Proceed with extra caution, manual verification required\n3. Abort refactoring\nWhich approach do you prefer?\n```\n## 3.4: Document Verification Plan\n```\n## VERIFICATION PLAN\n### Test Commands\n- Unit: `bun test` / `npm test` / `pytest` / etc.\n- Integration: [command if exists]\n- Type check: `tsc --noEmit` / `pyright` / etc.\n### Verification Checkpoints\nAfter each refactoring step:\n1. lsp_diagnostics → zero new errors\n2. Run test command → all pass\n3. Type check → clean\n### Regression Indicators\n- [Specific test that must pass]\n- [Behavior that must be preserved]\n- [API contract that must not change]\n```\n**Mark phase-3 as completed.**\n---\n# PHASE 4: PLAN GENERATION (PLAN AGENT)\n**Mark phase-4 as in_progress.**\n## 4.1: Invoke Plan Agent\n```\nTask(\n  subagent_type="do",\n  prompt="Create a detailed refactoring plan:\n  ## Refactoring Goal\n  [User\'s original request]\n  ## Codemap (from Phase 2)\n  [Insert codemap here]\n  ## Test Coverage (from Phase 3)\n  [Insert verification plan here]\n  ## Constraints\n  - MUST follow existing patterns: [list]\n  - MUST NOT break: [critical paths]\n  - MUST run tests after each step\n  ## Requirements\n  1. Break down into atomic refactoring steps\n  2. Each step must be independently verifiable\n  3. Order steps by dependency (what must happen first)\n  4. Specify exact files and line ranges for each step\n  5. Include rollback strategy for each step\n  6. Define commit checkpoints"\n)\n```\n## 4.2: Review and Validate Plan\nAfter receiving plan from Plan agent:\n1. **Verify completeness**: All identified files addressed?\n2. **Verify safety**: Each step reversible?\n3. **Verify order**: Dependencies respected?\n4. **Verify verification**: Test commands specified?\n## 4.3: Register Detailed Todos\nConvert Plan agent output into granular todos:\n```\nTodoWrite([\n  // Each step from the plan becomes a todo\n  {"id": "refactor-1", "content": "Step 1: [description]", "status": "pending", "priority": "high"},\n  {"id": "verify-1", "content": "Verify Step 1: run tests", "status": "pending", "priority": "high"},\n  {"id": "refactor-2", "content": "Step 2: [description]", "status": "pending", "priority": "medium"},\n  {"id": "verify-2", "content": "Verify Step 2: run tests", "status": "pending", "priority": "medium"},\n  // ... continue for all steps\n])\n```\n**Mark phase-4 as completed.**\n---\n# PHASE 5: EXECUTE REFACTORING (DETERMINISTIC EXECUTION)\n**Mark phase-5 as in_progress.**\n## 5.1: Execution Protocol\nFor EACH refactoring step:\n### Pre-Step\n1. Mark step todo as `in_progress`\n2. Read current file state\n3. Verify lsp_diagnostics is baseline\n### Execute Step\nUse appropriate tool:\n**For Symbol Renames:**\n```typescript\nlsp_prepare_rename(filePath, line, character)  // Validate rename is possible\nlsp_rename(filePath, line, character, newName)  // Execute rename\n```\n**For Pattern Transformations:**\n```typescript\n// Preview first\nast_grep_replace(pattern, rewrite, lang, dryRun=true)\n// If preview looks good, execute\nast_grep_replace(pattern, rewrite, lang, dryRun=false)\n```\n**For Structural Changes:**\n```typescript\n// Use Edit tool for precise changes\nedit(filePath, oldString, newString)\n```\n### Post-Step Verification (MANDATORY)\n```typescript\n// 1. Check diagnostics\nlsp_diagnostics(filePath)  // Must be clean or same as baseline\n// 2. Run tests\nbash("bun test")  // Or appropriate test command\n// 3. Type check\nbash("tsc --noEmit")  // Or appropriate type check\n```\n### Step Completion\n1. If verification passes → Mark step todo as `completed`\n2. If verification fails → **STOP AND FIX**\n## 5.2: Failure Recovery Protocol\nIf ANY verification fails:\n1. **STOP** immediately\n2. **REVERT** the failed change\n3. **DIAGNOSE** what went wrong\n4. **OPTIONS**:\n   - Fix the issue and retry\n   - Skip this step (if optional)\n   - Consult profile.advisor_plan agent for help\n   - Ask user for guidance\n**NEVER proceed to next step with broken tests.**\n## 5.3: Commit Checkpoints\nAfter each logical group of changes:\n```bash\ngit add [changed-files]\ngit commit -m "refactor(scope): description\n[details of what was changed and why]"\n```\n**Mark phase-5 as completed when all refactoring steps done.**\n---\n# PHASE 6: FINAL VERIFICATION (REGRESSION CHECK)\n**Mark phase-6 as in_progress.**\n## 6.1: Full Test Suite\n```bash\n# Run complete test suite\nbun test  # or npm test, pytest, go test, etc.\n```\n## 6.2: Type Check\n```bash\n# Full type check\ntsc --noEmit  # or equivalent\n```\n## 6.3: Lint Check\n```bash\n# Run linter\neslint .  # or equivalent\n```\n## 6.4: Build Verification (if applicable)\n```bash\n# Ensure build still works\nbun run build  # or npm run build, etc.\n```\n## 6.5: Final Diagnostics\n```typescript\n// Check all changed files\nfor (file of changedFiles) {\n  lsp_diagnostics(file)  // Must all be clean\n}\n```\n## 6.6: Generate Summary\n```markdown\n## Refactoring Complete\n### What Changed\n- [List of changes made]\n### Files Modified\n- `path/to/file.ts` - [what changed]\n- `path/to/file2.ts` - [what changed]\n### Verification Results\n- Tests: PASSED (X/Y passing)\n- Type Check: CLEAN\n- Lint: CLEAN\n- Build: SUCCESS\n### No Regressions Detected\nAll existing tests pass. No new errors introduced.\n```\n**Mark phase-6 as completed.**\n---\n# CRITICAL RULES\n## NEVER DO\n- Skip lsp_diagnostics check after changes\n- Proceed with failing tests\n- Make changes without understanding impact\n- Use `as any`, `@ts-ignore`, `@ts-expect-error`\n- Delete tests to make them pass\n- Commit broken code\n- Refactor without understanding existing patterns\n## ALWAYS DO\n- Understand before changing\n- Preview before applying (ast_grep dryRun=true)\n- Verify after every change\n- Follow existing codebase patterns\n- Keep todos updated in real-time\n- Commit at logical checkpoints\n- Report issues immediately\n## ABORT CONDITIONS\nIf any of these occur, **STOP and consult user**:\n- Test coverage is zero for target code\n- Changes would break public API\n- Refactoring scope is unclear\n- 3 consecutive verification failures\n- User-defined constraints violated\n---\n# Tool Usage Philosophy\nYou already know these tools. Use them intelligently:\n## LSP Tools\nLeverage LSP tools for precision analysis. Key patterns:\n- **Understand before changing**: `LspGotoDefinition` to grasp context\n- **Impact analysis**: `LspFindReferences` to map all usages before modification\n- **Safe refactoring**: `lsp_prepare_rename` → `lsp_rename` for symbol renames\n- **Continuous verification**: `lsp_diagnostics` after every change\n## AST-Grep\nUse `ast_grep_search` and `ast_grep_replace` for structural transformations.\n**Critical**: Always `dryRun=true` first, review, then execute.\n## Agents\n- `profile.researcher_codebase`: Parallel codebase pattern discovery\n- `plan`: Detailed refactoring plan generation\n- `profile.advisor_plan`: Read-only consultation for complex architectural decisions and debugging\n- `profile.researcher_data`: **Use proactively** when encountering deprecated methods or library migration tasks. Query official docs and OSS examples for modern replacements.\n## Deprecated Code & Library Migration\nWhen you encounter deprecated methods/APIs during refactoring:\n1. Fire `profile.researcher_data` to find the recommended modern alternative\n2. **DO NOT auto-upgrade to latest version** unless user explicitly requests migration\n3. If user requests library migration, use `profile.researcher_data` to fetch latest API docs before making changes\n---\n**Remember: Refactoring without tests is reckless. Refactoring without understanding is destructive. This command ensures you do neither.**\n<refactoring-target>\n$ARGUMENTS\n</refactoring-target>',
      argumentHint: "<target> [--scope=file|module|project] [--strategy=safe|aggressive]",
    },
  },
  {
    name: "ghostwire:util:backup",
    command: {
      description: "Create backups of project state and files",
      template:
        "\n# Util:Backup Command\nCreate backups of project state and important files.\n## Backup Types\n- **Project Snapshot** - Full project state at point in time\n- **Configuration** - Backup .env, config files\n- **Database** - Database dumps (if applicable)\n- **Selective** - Backup specific directories or file types\n## Features\n- Automatic compression (.tar.gz, .zip)\n- Timestamped backup names\n- Metadata and manifest creation\n- Encryption option\n- Multiple backup locations\n- Automatic cleanup of old backups\n## Output\n- Compressed backup file\n- Manifest with contents list\n- Hash for integrity verification\n- Restore instructions\n<backup-context>\n$ARGUMENTS\n</backup-context>\n",
      argumentHint: "[--type=snapshot|config|database|selective]",
    },
  },
  {
    name: "ghostwire:util:clean",
    command: {
      description: "Remove build artifacts and temporary files",
      template:
        "\n# Util:Clean Command\nRemove build artifacts, caches, temporary files, and other non-essential files.\n## What Gets Cleaned\n- **Build outputs** - dist/, build/, .next/, target/ directories\n- **Package caches** - node_modules/, .bun/, venv/, .cargo/ directories\n- **IDE artifacts** - .vscode/, .idea/, *.swp files\n- **OS artifacts** - .DS_Store, Thumbs.db\n- **Logs** - *.log, logs/ directory\n- **Temporary files** - tmp/, temp/ directories\n- **Generated files** - Coverage reports, build metadata\n## Levels\n- **Light** - Only OS and IDE artifacts\n- **Standard** - Build outputs and caches (safe to remove)\n- **Deep** - All non-essential including lockfiles\n- **Aggressive** - Everything except source code and config\n## Safety Features\n- Preview what will be deleted before confirmation\n- Preserve important files and directories\n- Never delete source code or git history\n- Option to dry-run before actual deletion\n- Backup option for deleted files\n<clean-context>\n$ARGUMENTS\n</clean-context>\n",
      argumentHint: "[--level=light|standard|deep|aggressive] [--dry-run]",
    },
  },
  {
    name: "ghostwire:util:doctor",
    command: {
      description: "Diagnose project health and configuration",
      template:
        "\n# Util:Doctor Command\nDiagnose project health and identify configuration issues.\n## Checks\n- **Dependencies** - Verify all dependencies installed and compatible\n- **Configuration** - Validate configuration files\n- **Environment** - Check required environment variables\n- **Tools** - Verify required tools installed (Node, Python, etc.)\n- **Git** - Check git status and history integrity\n- **Permissions** - Validate file permissions\n- **Disk Space** - Check available disk space\n- **Network** - Test required network connectivity\n## Features\n- Comprehensive health report\n- Actionable suggestions for issues found\n- One-command fixes for common problems\n- Configuration validation\n- Dependency version checking\n- Performance diagnostics\n## Output\n- Health status (✓ healthy, ⚠ warnings, ✗ errors)\n- Detailed report of issues found\n- Suggested fixes\n- Commands to run for automatic fixes\n<doctor-context>\n$ARGUMENTS\n</doctor-context>\n",
      argumentHint: "[--fix] [--verbose]",
    },
  },
  {
    name: "ghostwire:util:restore",
    command: {
      description: "Restore project from backup",
      template:
        "\n# Util:Restore Command\nRestore project from backup or specific point in time.\n## Restore Options\n- **Latest Backup** - Restore most recent backup\n- **Specific Backup** - Choose from backup history\n- **Selective Restore** - Restore only certain files\n- **Point in Time** - Restore to specific date/time\n## Process\n1. **Backup Verification** - Validate backup integrity\n2. **Restore Planning** - Show what will be restored\n3. **Confirmation** - Get user approval\n4. **Restore Execution** - Extract and restore files\n5. **Verification** - Validate restored files\n## Safety\n- Never overwrite without confirmation\n- Backup current state before restoring old state\n- Verify restore integrity\n- Provide rollback option\n- Log all restore operations\n<restore-context>\n$ARGUMENTS\n</restore-context>\n",
      argumentHint: "[backup-name] [--selective] [--dry-run]",
    },
  },
  {
    name: "ghostwire:work:cancel",
    command: {
      description: "Cancel active work loop",
      template:
        "\nCancel the currently active Ultrawork Loop.\nThis will:\n1. Stop the loop from continuing\n2. Clear the loop state file\n3. Allow the session to end normally\nCheck if a loop is active and cancel it. Inform the user of the result.\n",
    },
  },
  {
    name: "ghostwire:work:loop",
    command: {
      description:
        "Start iterative work loop until completion (ad-hoc, no plan required) [Phase: EXECUTE]",
      template:
        '\nYou are starting an Ultrawork Loop - a self-referential development loop that runs until task completion.\n## How\n1. You will work on the task continuously\n2. When you believe the task is FULLY complete, output: `<promise>{{COMPLETION_PROMISE}}</promise>`\n3. If you don\'t output the promise, the loop will automatically inject another prompt to continue\n4. Maximum iterations: Configurable (default 100)\n## Rules\n- Focus on completing the task fully, not partially\n- Don\'t output the completion promise until the task is truly done\n- Each iteration should make meaningful progress toward the goal\n- If stuck, try different approaches\n- Use todos to track your progress\n## Exit Conditions\n1. **Completion**: Output your completion promise tag when fully complete\n2. **Max Iterations**: Loop stops automatically at limit\n3. **Cancel**: User runs `/ghostwire:work:cancel` command\n## Your Task\nParse the arguments below and begin working on the task. The format is:\n`"task description" [--completion-promise=TEXT] [--max-iterations=N]`\nDefault completion promise is "DONE" and default max iterations is 100.\n<user-task>\n$ARGUMENTS\n</user-task>',
      argumentHint: '"task description" [--completion-promise=TEXT] [--max-iterations=N]',
    },
  },
  {
    name: "ghostwire:workflows:brainstorm",
    command: {
      description: "Explore requirements and approaches through collaborative dialogue",
      template:
        '\n# Brainstorm a Feature or Improvement\n**Note: The current year is 2026.** Use this when dating brainstorm documents.\nBrainstorming helps answer **WHAT** to build through collaborative dialogue. It precedes `/workflows:plan`, which answers **HOW** to build it.\n**Process knowledge:** Load the `brainstorming` skill for detailed question techniques, approach exploration patterns, and YAGNI principles.\n<feature-description>\n$ARGUMENTS\n</feature-description>\n**If the feature description above is empty, ask the user:** "What would you like to brainstorm? Please describe the feature, problem, or improvement you\'re thinking about."\nDo not proceed until you have a feature description from the user.\n## Execution Flow\n### Phase 0: Assess Requirements Clarity\nEvaluate whether brainstorming is needed based on the feature description.\n**Clear requirements indicators:**\n- Specific acceptance criteria provided\n- Referenced existing patterns to follow\n- Described exact expected behavior\n- Constrained, well-defined scope\n**If requirements are already clear:**\nUse **AskUserQuestion tool** to suggest: "Your requirements seem detailed enough to proceed directly to planning. Should I run `/workflows:plan` instead, or would you like to brainstorm the idea further?"\n### Phase 1: Understand the Idea\n#### 1.1 Repository Research (Lightweight)\nRun a quick repo scan to understand existing patterns:\n- Task profile.researcher_repo("Understand existing patterns related to: <feature_description>")\nFocus on: similar features, established patterns, CLAUDE.md guidance.\n#### 1.2 Collaborative Dialogue\nUse the **AskUserQuestion tool** to ask questions **one at a time**.\n**Guidelines (see `brainstorming` skill for detailed techniques):**\n- Prefer multiple choice when natural options exist\n- Start broad (purpose, users) then narrow (constraints, edge cases)\n- Validate assumptions explicitly\n- Ask about success criteria\n**Exit condition:** Continue until the idea is clear OR user says "proceed"\n### Phase 2: Explore Approaches\nPropose **2-3 concrete approaches** based on research and conversation.\nFor each approach, provide:\n- Brief description (2-3 sentences)\n- Pros and cons\n- When it\'s best suited\nLead with your recommendation and explain why. Apply YAGNI—prefer simpler solutions.\nUse **AskUserQuestion tool** to ask which approach the user prefers.\n### Phase 3: Capture the Design\nWrite a brainstorm document to `docs/brainstorms/YYYY-MM-DD-<topic>-brainstorm.md`.\n**Document structure:** See the `brainstorming` skill for the template format. Key sections: What We\'re Building, Why This Approach, Key Decisions, Open Questions.\nEnsure `docs/brainstorms/` directory exists before writing.\n### Phase 4: Handoff\nUse **AskUserQuestion tool** to present next steps:\n**Question:** "Brainstorm captured. What would you like to do next?"\n**Options:**\n1. **Proceed to planning** - Run `/workflows:plan` (will auto-detect this brainstorm)\n2. **Refine design further** - Continue exploring\n3. **Done for now** - Return later\n## Output Summary\nWhen complete, display:\n```\nBrainstorm complete!\nDocument: docs/brainstorms/YYYY-MM-DD-<topic>-brainstorm.md\nKey decisions:\n- [Decision 1]\n- [Decision 2]\nNext: Run `/workflows:plan` when ready to implement.\n```\n## Important Guidelines\n- **Stay focused on WHAT, not HOW** - Implementation details belong in the plan\n- **Ask one question at a time** - Don\'t overwhelm\n- **Apply YAGNI** - Prefer simpler approaches\n- **Keep outputs concise** - 200-300 words per section max\nNEVER CODE! Just brainstorm and document decisions.\n</feature-description>',
      argumentHint: "[feature description]",
    },
  },
  {
    name: "ghostwire:workflows:complete",
    command: {
      description: "Finalize and archive completed workflow",
      template:
        "\n# Workflows:Complete Command\nFinalize and archive a completed workflow.\n## Process\n1. **Verify Completion** - Confirm all acceptance criteria met\n2. **Collect Results** - Gather outputs and artifacts\n3. **Document Learnings (MANDATORY)** - Trigger /ghostwire:workflows:learnings with workflow context\n4. **Archive Plan** - Move to completed state\n5. **Generate Summary** - Create completion report\n## Enforcement\n- MANDATORY: Trigger /ghostwire:workflows:learnings before final completion output.\n- Do not mark workflow complete unless learnings capture has been attempted.\n- If learnings capture fails, report failure explicitly and stop before archive step.\n## Output\n- Completion summary document\n- Artifacts and references\n- Institutional learning record (if applicable)\n- Next steps or follow-up items\n<workflow-reference>\n$ARGUMENTS\n</workflow-reference>",
      argumentHint: "[workflow-reference]",
    },
  },
  {
    name: "ghostwire:workflows:create",
    command: {
      description:
        "Generate lifecycle artifacts in strict submodes: tasks|analyze|checklist|issues [Phase: BREAKDOWN]",
      template:
        '\n# Workflows:Create Command (Canonical Multi-Mode)\nCreate deterministic lifecycle artifacts from an approved plan.\n## Invocation\n- Default: /ghostwire:workflows:create <plan-reference> => tasks\n- Explicit: /ghostwire:workflows:create --mode <tasks|analyze|checklist|issues> <plan-reference>\n## Input\n<plan-reference>\n$ARGUMENTS\n</plan-reference>\n## Mode Resolution Rules\n1. If --mode is provided, use it.\n2. If no mode is provided, default to `tasks`.\n## Shared Preconditions (All Modes)\n- Plan file must be readable and located under .ghostwire/plans/*.md\n- Plan must include acceptance criteria and implementation steps\n- If required data is missing, fail-fast and report exact missing fields\n## --mode tasks (default)\n### Output Contract\n- Phases: Setup (1), Foundational (2, blocking), User Story phases (3+), Polish (final)\n- Format each task as: `[ID] [P?] [Story?] Description`\n- [P] indicates parallelizable tasks\n- Include exact repository file paths in each task description\n- Enforce dependencies: Foundational blocks stories; tests-before-implementation where applicable; models -> services -> endpoints -> integration\n- Output phase dependencies, story dependencies, and parallel opportunities\n## --mode analyze\n### Output Contract\n- Artifact inventory matrix (plan, tasks, research, data model, contracts, quickstart, checklists)\n- Plan-to-task alignment checks\n- Requirement coverage checks (FR/SC traceability)\n- Severity-tagged findings (critical/high/medium/low)\n- Deterministic remediation checklist\n- Every finding must include evidence location\n- Every critical finding must include a concrete remediation step\n- If no issues, explicitly state "No critical inconsistencies detected"\n## --mode checklist\n### Output Contract\n- Generate a checklist for one domain: security, performance, data-integrity, accessibility, deployment, or testing\n- Checkboxes only (`- [ ]`)\n- Each item includes pass/fail criterion\n- Include completion rule set\n- Do not include implementation prose beyond checklist items and criteria\n- Must be directly actionable by executor without interpretation\n## --mode issues\n### Output Contract\n- Mapping table: task ID -> issue title -> dependencies -> labels\n- Ready-to-run GH CLI command set\n- Batch sequencing strategy for dependency-safe issue creation\n- Commands must reference deterministic titles\n- Include dependency notes for blocked tasks\n- Include total counts by phase\n## Integration and Handoff\n- tasks mode feeds /ghostwire:workflows:work\n- analyze/checklist modes gate execution readiness\n- issues mode prepares tracker synchronization\n## Final Validation (All Modes)\nBefore finalizing output:\n- Confirm selected mode explicitly in output header\n- Confirm plan reference path\n- Confirm deterministic format constraints were met\n- If constraints fail, regenerate\n<plan-reference>\n$ARGUMENTS\n</plan-reference>',
      argumentHint: "[--mode tasks|analyze|checklist|issues] [plan-name-or-path]",
    },
  },
  {
    name: "ghostwire:workflows:execute",
    command: {
      description:
        "Execute planned tasks from workflow plan (task-driven, with subagent delegation) [Phase: EXECUTE]",
      template:
        '\nYou are starting a workflow coordinator work session.\n## WHAT TO DO\n1. **Find available plans**: Search for workflow coordinator-generated plan files at `.ghostwire/plans/`\n2. **Check for active ultrawork state**: Read `.ghostwire/ultrawork.json` if it exists\n3. **Decision logic**:\n   - If `.ghostwire/ultrawork.json` exists AND plan is NOT complete (has unchecked boxes):\n     - **APPEND** current session to session_ids\n     - Continue work on existing plan\n   - If no active plan OR plan is complete:\n     - List available plan files\n     - If ONE plan: auto-select it\n     - If MULTIPLE plans: show list with timestamps, ask user to select\n4. **Create/Update ultrawork.json**:\n   ```json\n   {\n     "active_plan": "/absolute/path/to/plan.md",\n     "started_at": "ISO_TIMESTAMP",\n     "session_ids": ["session_id_1", "session_id_2"],\n     "plan_name": "plan-name"\n   }\n   ```\n5. **Read the plan file** and start executing tasks according to do/research workflow\n## OUTPUT FORMAT\nWhen listing plans for selection:\n```\nAvailable Work Plans\nCurrent Time: {ISO timestamp}\nSession ID: {current session id}\n1. [plan-name-1.md] - Modified: {date} - Progress: 3/10 tasks\n2. [plan-name-2.md] - Modified: {date} - Progress: 0/5 tasks\nWhich plan would you like to work on? (Enter number or plan name)\n```\nWhen resuming existing work:\n```\nResuming Work Session\nActive Plan: {plan-name}\nProgress: {completed}/{total} tasks\nSessions: {count} (appending current session)\nReading plan and continuing from last incomplete task...\n```\nWhen auto-selecting single plan:\n```\nStarting Work Session\nPlan: {plan-name}\nSession ID: {session_id}\nStarted: {timestamp}\nReading plan and beginning execution...\n```\n## CRITICAL\n- The session_id is injected by the hook - use it directly\n- Always update ultrawork.json BEFORE starting work\n- Read the FULL plan file before delegating any tasks\n- Follow workflow coordinator delegation protocols and workflow coordinator handoff checklist (7-section format with safety checks)\n<session-context>\nSession ID: $SESSION_ID\nTimestamp: $TIMESTAMP\n</session-context>\n<user-request>\n$ARGUMENTS\n</user-request>',
      argumentHint: "[plan-name]",
    },
  },
  {
    name: "ghostwire:workflows:learnings",
    command: {
      description: "Document a recently solved problem to build team learnings",
      template:
        '\n# /learnings\nCoordinate multiple subagents working in parallel to document a recently solved problem.\n## Purpose\nCaptures problem solutions while context is fresh, creating structured documentation in `docs/learnings/` with YAML frontmatter for searchability and future reference. Uses parallel subagents for maximum efficiency.\n**Why "learnings"?** Each documented solution builds your team\'s knowledge. The first time you solve a problem takes research. Document it, and the next occurrence takes minutes. Knowledge accumulates.\n## Usage\n```bash\n/workflows:learnings                    # Document the most recent fix\n/workflows:learnings [brief context]    # Provide additional context hint\n```\n## Execution Strategy: Parallel Subagents\nThis command launches multiple specialized subagents IN PARALLEL to maximize efficiency:\n### 1. **Context Analyzer** (Parallel)\n- Extracts conversation history\n- Identifies problem type, component, symptoms\n- Validates against solution schema\n- Returns: YAML frontmatter skeleton\n### 2. **Solution Extractor** (Parallel)\n- Analyzes all investigation steps\n- Identifies root cause\n- Extracts working solution with code examples\n- Returns: Solution content block\n### 3. **Related Docs Finder** (Parallel)\n- Searches `docs/learnings/` for related documentation\n- Identifies cross-references and links\n- Finds related GitHub issues\n- Returns: Links and relationships\n### 4. **Prevention Strategist** (Parallel)\n- Develops prevention strategies\n- Creates best practices guidance\n- Generates test cases if applicable\n- Returns: Prevention/testing content\n### 5. **Category Classifier** (Parallel)\n- Determines optimal `docs/learnings/` category\n- Validates category against schema\n- Suggests filename based on slug\n- Returns: Final path and filename\n### 6. **Documentation Writer** (Parallel)\n- Assembles complete markdown file\n- Validates YAML frontmatter\n- Formats content for readability\n- Creates the file in correct location\n### 7. **Optional: Specialized Agent Invocation** (Post-Documentation)\nBased on problem type detected, automatically invoke applicable agents:\n- **performance_issue** → `profile.oracle_performance`\n- **security_issue** → `profile.reviewer_security`\n- **database_issue** → `profile.guardian_data`\n- **test_failure** → Use skill "cora-test-reviewer" (not an agent)\n- Any code-heavy issue → `profile.reviewer_rails` + `profile.reviewer_simplicity`\n## What It Captures\n- **Problem symptom**: Exact error messages, observable behavior\n- **Investigation steps tried**: What didn\'t work and why\n- **Root cause analysis**: Technical explanation\n- **Working solution**: Step-by-step fix with code examples\n- **Prevention strategies**: How to avoid in future\n- **Cross-references**: Links to related issues and docs\n## Preconditions\n<preconditions enforcement="advisory">\n  <check condition="problem_solved">\n    Problem has been solved (not in-progress)\n  </check>\n  <check condition="solution_verified">\n    Solution has been verified working\n  </check>\n  <check condition="non_trivial">\n    Non-trivial problem (not simple typo or obvious error)\n  </check>\n</preconditions>\n## What It Creates\n**Organized documentation:**\n- File: `docs/learnings/[category]/[filename].md`\n**Categories auto-detected from problem:**\n- build-errors/\n- test-failures/\n- runtime-errors/\n- performance-issues/\n- database-issues/\n- security-issues/\n- ui-bugs/\n- integration-issues/\n- logic-errors/\n## Success Output\n```\n✓ Parallel documentation generation complete\nPrimary Subagent Results:\n  ✓ Context Analyzer: Identified performance_issue in brief_system\n  ✓ Solution Extractor: Extracted 3 code fixes\n  ✓ Related Docs Finder: Found 2 related issues\n  ✓ Prevention Strategist: Generated test cases\n  ✓ Category Classifier: docs/learnings/performance-issues/\n  ✓ Documentation Writer: Created complete markdown\nSpecialized Agent Reviews (Auto-Triggered):\n  ✓ profile.oracle_performance: Validated query optimization approach\n  ✓ profile.reviewer_rails: Code examples meet Rails standards\n  ✓ profile.reviewer_simplicity: Solution is appropriately minimal\n  ✓ every-style-editor: Documentation style verified\nFile created:\n- docs/learnings/performance-issues/n-plus-one-brief-generation.md\nThis documentation will be searchable for future reference when similar\nissues occur in the Email Processing or Brief System modules.\nWhat\'s next?\n1. Continue workflow (recommended)\n2. Link related documentation\n3. Update other references\n4. View documentation\n5. Other\n```\n## The Compounding philosophy\nThis creates a learnings knowledge system:\n1. First time you solve "N+1 query in brief generation" → Research (30 min)\n2. Document the solution → docs/learnings/performance-issues/n-plus-one-briefs.md (5 min)\n3. Next time similar issue occurs → Quick lookup (2 min)\n4. Knowledge builds → Team gets smarter\nThe feedback loop:\n```\nBuild → Test → Find Issue → Research → Improve → Document → Validate → Deploy\n    ↑                                                                      ↓\n    └──────────────────────────────────────────────────────────────────────┘\n```\n**Each unit of engineering work should make subsequent units of work easier—not harder.**\n## Auto-Invoke\n<auto_invoke> <trigger_phrases> - "that worked" - "it\'s fixed" - "working now" - "problem solved" </trigger_phrases>\n<manual_override> Use /workflows:learnings [context] to document immediately without waiting for auto-detection. </manual_override> </auto_invoke>\n## Routes To\n`learnings` skill\n## Applicable Specialized Agents\nBased on problem type, these agents can enhance documentation:\n### Code Quality & Review\n- **profile.reviewer_rails**: Reviews code examples for Rails best practices\n- **profile.reviewer_simplicity**: Ensures solution code is minimal and clear\n- **profile.analyzer_patterns**: Identifies anti-patterns or repeating issues\n### Specific Domain Experts\n- **profile.oracle_performance**: Analyzes performance_issue category solutions\n- **profile.reviewer_security**: Reviews security_issue solutions for vulnerabilities\n- **cora-test-reviewer**: (skill, not agent) Creates test cases for prevention strategies\n- **profile.guardian_data**: Reviews database_issue migrations and queries\n### Enhancement & Documentation\n- **profile.researcher_practices**: Enriches solution with industry best practices\n- **every-style-editor**: Reviews documentation style and clarity\n- **profile.researcher_docs**: Links to Rails/gem documentation references\n### When to Invoke\n- **Auto-triggered** (optional): Agents can run post-documentation for enhancement\n- **Manual trigger**: User can invoke agents after /workflows:learnings completes for deeper review\n## Related Commands\n- `/research [topic]` - Deep investigation (searches docs/learnings/ for patterns)\n- `/workflows:plan` - Planning workflow (references documented solutions)\n',
      argumentHint: "[context]",
    },
  },
  {
    name: "ghostwire:workflows:plan",
    command: {
      description:
        "Transform feature descriptions into implementation plans with strict story+requirements contracts [Phase: PLAN]",
      template:
        '\nNote: The current year is 2026. Use 2026 for date-sensitive references unless the system date differs.\n# Workflows:Plan Command (Canonical)\nTransform a feature request, bug report, or refactor idea into one strictly formatted plan document.\n## Input\n<feature-description>\n$ARGUMENTS\n</feature-description>\nIf the feature description is empty, ask:\n"What should I plan? Provide the feature, bug, or refactor scope."\nDo not continue until scope is explicit.\n## Required Execution Pipeline\n1. Brainstorm first\n- Check for brainstorm artifacts in docs/brainstorms/.\n- Use latest relevant brainstorm if present; otherwise run a short AskUserQuestion brainstorm.\n- Capture explicit decisions and open questions.\n2. Run mandatory local research\n- Run in parallel:\n  - Task profile.researcher_repo(feature_description)\n  - Task profile.researcher_learnings(feature_description)\n- Capture file-level evidence with line refs and project conventions.\n3. Run mandatory external research\n- Run in parallel:\n  - Task profile.researcher_practices(feature_description)\n  - Task profile.researcher_docs(feature_description)\n- Use current authoritative sources and include at least 2 relevant external refs when applicable.\n4. Run NEEDS CLARIFICATION scan (mandatory)\n- Find unresolved ambiguity and missing acceptance definitions.\n- If unresolved items remain, ask user before finalizing.\n5. Consolidate research\n- Synthesize local patterns, institutional learnings, external guidance, tradeoffs, and risks.\n6. Setup issue tracking metadata\n- Detect tracker preference from CLAUDE.md (`github` or `linear`), else ask user.\n- Set frontmatter `issue_tracker` and `issue_url` (`pending` if not created).\n7. Write plan file\n- Write to: .ghostwire/plans/YYYY-MM-DD-descriptive-name-plan.md\n- type must be one of: feat, fix, refactor\n- Use kebab-case; filename starts with date prefix.\n- Never write plan files outside .ghostwire/plans/.\n- If additional artifacts are needed, declare intent under .ghostwire/plans/<plan-id>/ (spec.md, research.md, data-model.md, contracts/, quickstart.md, tasks.md, analysis.md, checklists/).\n## Output Contract\nUse exactly this output format.\n~~~markdown\n---\ntitle: "<type>: <clear action-oriented title>"\ntype: feat|fix|refactor\ndate: YYYY-MM-DD\nstatus: draft|ready|completed|example\nissue_tracker: github|linear|other\nissue_url: pending|https://...\nfeature_description: "<original user request, normalized>"\n---\n# <type>: <clear action-oriented title>\n## Problem Statement\n[Concise technical statement of the problem or opportunity.]\n## User Scenarios & Testing (Mandatory)\n### User Story 1 (P1)\n- Narrative:\n- Independent test:\n- Acceptance scenarios:\n  - Given ... When ... Then ...\n### User Story 2 (P2)\n- Narrative:\n- Independent test:\n- Acceptance scenarios:\n  - Given ... When ... Then ...\n### Edge Cases\n- Edge case 1\n- Edge case 2\n## Requirements (Mandatory)\n### Functional Requirements\n- **FR-001**: ...\n- **FR-002**: ...\n- **FR-003**: ...\n### Key Entities\n- Entity 1\n- Entity 2\n## Success Criteria (Mandatory)\n- **SC-001**: measurable outcome\n- **SC-002**: measurable outcome\n- **SC-003**: measurable outcome\n## Goals and Non-Goals\n### Goals\n- [ ] Goal 1\n- [ ] Goal 2\n### Non-Goals\n- [ ] Non-goal 1\n## Technical Context\n- Language/Version:\n- Primary Dependencies:\n- Storage:\n- Testing:\n- Target Platform:\n- Constraints:\n- Scale/Scope:\n## Constitution Gate\n- Gate status: PASS|FAIL\n- Violations and justifications (if any)\n## Brainstorm Decisions\n- Decision 1\n- Decision 2\n## Clarifications\n- Open questions discovered:\n- Resolutions:\n## Research Summary\n### Local Findings\n- [path/to/file.ts:line] Pattern or constraint\n### External Findings\n- [Source name](https://example.com): recommendation\n### Risks and Unknowns\n- Risk 1 and mitigation\n## Proposed Approach\n[Architecture and execution strategy.]\n## Acceptance Criteria\n- [ ] Functional criterion 1\n- [ ] Functional criterion 2\n- [ ] Non-functional criterion (performance/security/reliability)\n## Implementation Steps\n- [ ] Step with scope and expected artifact\n- [ ] Step with validation method\n- [ ] Step with rollout or migration considerations\n## Testing Strategy\n- Unit:\n- Integration:\n- End-to-end:\n## Dependencies and Rollout\n- Dependencies:\n- Sequencing:\n- Rollback:\n## Artifact Plan (Optional Detail Directory)\n- Detail root: .ghostwire/plans/<plan-id>/\n- Optional artifacts: spec.md, research.md, data-model.md, contracts/, quickstart.md, tasks.md, analysis.md, checklists/\n## References\n- Internal: [path/to/file.ts:line]\n- External: [Source](https://example.com)\n- Related issue/PR: #123\n~~~\n## Required Plan Validation (Before Finalizing)\nBefore finalizing, verify all conditions:\n- Frontmatter exists and is the very first block in the file.\n- Frontmatter includes exactly these required keys at minimum: title, type, date, status.\n- date format is strictly YYYY-MM-DD.\n- status is one of: draft, ready, completed, example.\n- The first H1 after frontmatter matches frontmatter title semantics.\n- The document includes all required sections from the output contract.\n- User Scenarios & Testing, Functional Requirements, and Success Criteria are present.\n- NEEDS CLARIFICATION scan found no unresolved items.\n- Implementation Steps uses checkbox tasks (`- [ ]`) and no numbered list.\n- Metadata fields belong in frontmatter; do not duplicate status/date/author/priority block lines in the body preamble.\n- File path matches `.ghostwire/plans/YYYY-MM-DD-*.md`.\n- title, type, date, status are valid and coherent.\n## Post-Generation Tracking Step\nAfter writing the plan:\n1. Ask whether to create an issue now.\n2. If yes (GitHub): gh issue create --title "<type>: <title>" --body-file <plan_path>\n3. If yes (Linear): linear issue create --title "<type>: <title>" --description "$(cat <plan_path>)"\n4. Update `issue_url`.\n5. Ask whether to continue with /workflows:create.\nNEVER implement code in this command. Produce planning output only.\n',
      argumentHint: "[feature description, bug report, or improvement idea]",
    },
  },
  {
    name: "ghostwire:workflows:review",
    command: {
      description: "Perform exhaustive code reviews using multi-agent analysis",
      template:
        '\n# Review Command\n<command_purpose> Perform exhaustive code reviews using multi-agent analysis, ultra-thinking, and Git worktrees for deep local inspection. </command_purpose>\n## Introduction\n<role>Senior Code Review Architect with expertise in security, performance, architecture, and quality assurance</role>\n## Prerequisites\n<requirements>\n- Git repository with GitHub CLI (`gh`) installed and authenticated\n- Clean main/master branch\n- Proper permissions to create worktrees and access the repository\n- For document reviews: Path to a markdown file or document\n</requirements>\n## Main Tasks\n### 1. Determine Review Target & Setup (ALWAYS FIRST)\n<review_target> #<review-request>$ARGUMENTS</review-request> </review_target>\n<thinking>\nFirst, I need to determine the review target type and set up the code for analysis.\n</thinking>\n#### Immediate Actions:\n<task_list>\n- [ ] Determine review type: PR number (numeric), GitHub URL, file path (.md), or empty (current branch)\n- [ ] Check current git branch\n- [ ] If ALREADY on the target branch (PR branch, requested branch name, or the branch already checked out for review) → proceed with analysis on current branch\n- [ ] If DIFFERENT branch than the review target → offer to use worktree: "Use git-worktree skill for isolated Call `skill: git-worktree` with branch name\n- [ ] Fetch PR metadata using `gh pr view --json` for title, body, files, linked issues\n- [ ] Set up language-specific analysis tools\n- [ ] Prepare security scanning environment\n- [ ] Make sure we are on the branch we are reviewing. Use gh pr checkout to switch to the branch or manually checkout the branch.\nEnsure that the code is ready for analysis (either in worktree or on current branch). ONLY then proceed to the next step.\n</task_list>\n#### Parallel Agents to review the PR:\n<parallel_tasks>\nRun ALL or most of these agents at the same time:\n1. Task profile.reviewer_rails_dh(PR title)\n2. If turbo is used: Use skill "rails-turbo-expert" (not an agent)\n3. Task profile.researcher_git(PR content)\n4. Task profile.expert_migrations(PR content)\n5. Task profile.analyzer_patterns(PR content)\n6. Task profile.advisor_architecture(PR content)\n7. Task profile.reviewer_simplicity(PR content)\n8. Task profile.reviewer_security(PR content)\n9. Task profile.oracle_performance(PR content)\n10. Task profile.validator_deployment(PR content)\n11. Task profile.guardian_data(PR content)\n12. Task profile.reviewer_rails(PR content) - Verify new features are agent-accessible\n</parallel_tasks>\n#### Conditional Agents (Run if applicable):\n<conditional_agents>\nThese agents are run ONLY when the PR matches specific criteria. Check the PR files list to determine if they apply:\n**If PR contains database migrations (db/migrate/*.rb files) or data backfills:**\n14. Task profile.expert_migrations(PR content) - Validates ID mappings match production, checks for swapped values, verifies rollback safety\n15. Task profile.validator_deployment(PR content) - Creates Go/No-Go deployment checklist with SQL verification queries\n**When to run migration agents:**\n- PR includes files matching `db/migrate/*.rb`\n- PR modifies columns that store IDs, enums, or mappings\n- PR includes data backfill scripts or rake tasks\n- PR changes how data is read/written (e.g., changing from FK to string column)\n- PR title/body mentions: migration, backfill, data transformation, ID mapping\n**What these agents check:**\n- `profile.expert_migrations`: Verifies hard-coded mappings match production reality (prevents swapped IDs), checks for orphaned associations, validates dual-write patterns\n- `profile.validator_deployment`: Produces executable pre/post-deploy checklists with SQL queries, rollback procedures, and monitoring plans\n</conditional_agents>\n### 4. Ultra-Thinking Deep Dive Phases\n<ultrathink_instruction> For each phase below, spend maximum cognitive effort. Think step by step. Consider all angles. Question assumptions. And bring all reviews in a synthesis to the user.</ultrathink_instruction>\n<deliverable>\nComplete system context map with component interactions\n</deliverable>\n#### Phase 3: Stakeholder Perspective Analysis\n<thinking_prompt> ULTRA-THINK: Put yourself in each stakeholder\'s shoes. What matters to them? What are their pain points? </thinking_prompt>\n<stakeholder_perspectives>\n1. **Developer Perspective** <questions>\n   - How easy is this to understand and modify?\n   - Are the APIs intuitive?\n   - Is debugging straightforward?\n   - Can I test this easily? </questions>\n2. **Operations Perspective** <questions>\n   - How do I deploy this safely?\n   - What metrics and logs are available?\n   - How do I troubleshoot issues?\n   - What are the resource requirements? </questions>\n3. **End User Perspective** <questions>\n   - Is the feature intuitive?\n   - Are error messages helpful?\n   - Is performance acceptable?\n   - Does it solve my problem? </questions>\n4. **Security Team Perspective** <questions>\n   - What\'s the attack surface?\n   - Are there compliance requirements?\n   - How is data protected?\n   - What are the audit capabilities? </questions>\n5. **Business Perspective** <questions>\n   - What\'s the ROI?\n   - Are there legal/compliance risks?\n   - How does this affect time-to-market?\n   - What\'s the total cost of ownership? </questions> </stakeholder_perspectives>\n#### Phase 4: Scenario Exploration\n<thinking_prompt> ULTRA-THINK: Scout Recon edge cases and failure scenarios. What could go wrong? How does the system behave under stress? </thinking_prompt>\n<scenario_checklist>\n- [ ] **Happy Path**: Normal operation with valid inputs\n- [ ] **Invalid Inputs**: Null, empty, malformed data\n- [ ] **Boundary Conditions**: Min/max values, empty collections\n- [ ] **Concurrent Access**: Race conditions, deadlocks\n- [ ] **Scale Testing**: 10x, 100x, 1000x normal load\n- [ ] **Network Issues**: Timeouts, partial failures\n- [ ] **Resource Exhaustion**: Memory, disk, connections\n- [ ] **Security Attacks**: Injection, overflow, DoS\n- [ ] **Data Corruption**: Partial writes, inconsistency\n- [ ] **Cascading Failures**: Downstream service issues </scenario_checklist>\n### 6. Multi-Angle Review Perspectives\n#### Technical Excellence Angle\n- Code craftsmanship evaluation\n- Engineering best practices\n- Technical documentation quality\n- Tooling and automation assessment\n#### Business Value Angle\n- Feature completeness validation\n- Performance impact on users\n- Cost-benefit analysis\n- Time-to-market considerations\n#### Risk Management Angle\n- Security risk assessment\n- Operational risk evaluation\n- Compliance risk verification\n- Technical debt accumulation\n#### Team Dynamics Angle\n- Code review etiquette\n- Knowledge sharing effectiveness\n- Collaboration patterns\n- Mentoring opportunities\n### 4. Simplification and Minimalism Review\nRun the Task profile.reviewer_simplicity() to see if we can simplify the code.\n### 5. Findings Synthesis and Todo Creation Using file-todos Skill\n<critical_requirement> ALL findings MUST be stored in the todos/ directory using the file-todos skill. Create todo files immediately after synthesis - do NOT present findings for user approval first. Use the skill for structured todo management. </critical_requirement>\n#### Step 1: Synthesize All Findings\n<thinking>\nConsolidate all agent reports into a categorized list of findings.\nRemove duplicates, prioritize by severity and impact.\n</thinking>\n<synthesis_tasks>\n- [ ] Collect findings from all parallel agents\n- [ ] Categorize by type: security, performance, architecture, quality, etc.\n- [ ] Assign severity levels: 🔴 CRITICAL (P1), 🟡 IMPORTANT (P2), 🔵 NICE-TO-HAVE (P3)\n- [ ] Remove duplicate or overlapping findings\n- [ ] Estimate effort for each finding (Small/Medium/Large)\n</synthesis_tasks>\n#### Step 2: Create Todo Files Using file-todos Skill\n<critical_instruction> Use the file-todos skill to create todo files for ALL findings immediately. Do NOT present findings one-by-one asking for user approval. Create all todo files in parallel using the skill, then summarize results to user. </critical_instruction>\n**Implementation Options:**\n**Option A: Direct File Creation (Fast)**\n- Create todo files directly using Write tool\n- All findings in parallel for speed\n- Use standard template from `.claude/skills/file-todos/assets/todo-template.md`\n- Follow naming convention: `{issue_id}-pending-{priority}-{description}.md`\n**Option B: Sub-Agents in Parallel (Recommended for Scale)** For large PRs with 15+ findings, use sub-agents to create finding files in parallel:\n```bash\n# Launch multiple finding-creator agents in parallel\nTask() - Create todos for first finding\nTask() - Create todos for second finding\nTask() - Create todos for third finding\netc. for each finding.\n```\nSub-agents can:\n- Process multiple findings simultaneously\n- Write detailed todo files with all sections filled\n- Organize findings by severity\n- Create comprehensive Proposed Solutions\n- Add acceptance criteria and work logs\n- Complete much faster than sequential processing\n**Execution Strategy:**\n1. Synthesize all findings into categories (P1/P2/P3)\n2. Group findings by severity\n3. Launch 3 parallel sub-agents (one per severity level)\n4. Each sub-agent creates its batch of todos using the file-todos skill\n5. Consolidate results and present summary\n**Process (Using file-todos Skill):**\n1. For each finding:\n   - Determine severity (P1/P2/P3)\n   - Write detailed Problem Statement and Findings\n   - Create 2-3 Proposed Solutions with pros/cons/effort/risk\n   - Estimate effort (Small/Medium/Large)\n   - Add acceptance criteria and work log\n2. Use file-todos skill for structured todo management:\n   ```bash\n   skill: file-todos\n   ```\n   The skill provides:\n   - Template location: `.claude/skills/file-todos/assets/todo-template.md`\n   - Naming convention: `{issue_id}-{status}-{priority}-{description}.md`\n   - YAML frontmatter structure: status, priority, issue_id, tags, dependencies\n   - All required sections: Problem Statement, Findings, Solutions, etc.\n3. Create todo files in parallel:\n   ```bash\n   {next_id}-pending-{priority}-{description}.md\n   ```\n4. Examples:\n   ```\n   001-pending-p1-path-traversal-vulnerability.md\n   002-pending-p1-api-response-validation.md\n   003-pending-p2-concurrency-limit.md\n   004-pending-p3-unused-parameter.md\n   ```\n5. Follow template structure from file-todos skill: `.claude/skills/file-todos/assets/todo-template.md`\n**Todo File Structure (from template):**\nEach todo must include:\n- **YAML frontmatter**: status, priority, issue_id, tags, dependencies\n- **Problem Statement**: What\'s broken/missing, why it matters\n- **Findings**: Discoveries from agents with evidence/location\n- **Proposed Solutions**: 2-3 options, each with pros/cons/effort/risk\n- **Recommended Action**: (Filled during triage, leave blank initially)\n- **Technical Details**: Affected files, components, database changes\n- **Acceptance Criteria**: Testable checklist items\n- **Work Log**: Dated record with actions and learnings\n- **Resources**: Links to PR, issues, documentation, similar patterns\n**File naming convention:**\n```\n{issue_id}-{status}-{priority}-{description}.md\nExamples:\n- 001-pending-p1-security-vulnerability.md\n- 002-pending-p2-performance-optimization.md\n- 003-pending-p3-code-cleanup.md\n```\n**Status values:**\n- `pending` - New findings, needs triage/decision\n- `ready` - Approved by manager, ready to work\n- `complete` - Work finished\n**Priority values:**\n- `p1` - Critical (blocks merge, security/data issues)\n- `p2` - Important (should fix, architectural/performance)\n- `p3` - Nice-to-have (enhancements, cleanup)\n**Tagging:** Always add `code-review` tag, plus: `security`, `performance`, `architecture`, `rails`, `quality`, etc.\n#### Step 3: Summary Report\nAfter creating all todo files, present comprehensive summary:\n````markdown\n## ✅ Code Review Complete\n**Review Target:** PR #XXXX - [PR Title] **Branch:** [branch-name]\n### Findings Summary:\n- **Total Findings:** [X]\n- **🔴 CRITICAL (P1):** [count] - BLOCKS MERGE\n- **🟡 IMPORTANT (P2):** [count] - Should Fix\n- **🔵 NICE-TO-HAVE (P3):** [count] - Enhancements\n### Created Todo Files:\n**P1 - Critical (BLOCKS MERGE):**\n- `001-pending-p1-{finding}.md` - {description}\n- `002-pending-p1-{finding}.md` - {description}\n**P2 - Important:**\n- `003-pending-p2-{finding}.md` - {description}\n- `004-pending-p2-{finding}.md` - {description}\n**P3 - Nice-to-Have:**\n- `005-pending-p3-{finding}.md` - {description}\n### Review Agents Used:\n- profile.reviewer_rails\n- profile.reviewer_security\n- profile.oracle_performance\n- profile.advisor_architecture\n- [other agents]\n### Next Steps:\n1. **Address P1 Findings**: CRITICAL - must be fixed before merge\n   - Review each P1 todo in detail\n   - Implement fixes or request exemption\n   - Verify fixes before merging PR\n2. **Triage All Todos**:\n   ```bash\n   ls todos/*-pending-*.md  # View all pending todos\n   /triage                  # Use slash command for interactive triage\n   ```\n3. **Work on Approved Todos**:\n   ```bash\n   /resolve_todo_parallel  # Fix all approved items efficiently\n   ```\n4. **Track Progress**:\n   - Rename file when status changes: pending → ready → complete\n   - Update Work Log as you work\n   - Commit todos: `git add todos/ && git commit -m "refactor: add code review findings"`\n### Severity Breakdown:\n**🔴 P1 (Critical - Blocks Merge):**\n- Security vulnerabilities\n- Data corruption risks\n- Breaking changes\n- Critical architectural issues\n**🟡 P2 (Important - Should Fix):**\n- Performance issues\n- Significant architectural concerns\n- Major code quality problems\n- Reliability issues\n**🔵 P3 (Nice-to-Have):**\n- Minor improvements\n- Code cleanup\n- Optimization opportunities\n- Documentation updates\n```\n### 7. End-to-End Testing (Optional)\n<detect_project_type>\n**First, detect the project type from PR files:**\n| Indicator | Project Type |\n|-----------|--------------|\n| `*.xcodeproj`, `*.xcworkspace`, `Package.swift` (iOS) | iOS/macOS |\n| `Gemfile`, `package.json`, `app/views/*`, `*.html.*` | Web |\n| Both iOS files AND web files | Hybrid (test both) |\n</detect_project_type>\n<offer_testing>\nAfter presenting the Summary Report, offer appropriate testing based on project type:\n**For Web Projects:**\n```markdown\n**"Want to run browser tests on the affected pages?"**\n1. Yes - run `/test-browser`\n2. No - skip\n```\n**For iOS Projects:**\n```markdown\n**"Want to run Xcode simulator tests on the app?"**\n1. Yes - run `/xcode-test`\n2. No - skip\n```\n**For Hybrid Projects (e.g., Rails + Hotwire Native):**\n```markdown\n**"Want to run end-to-end tests?"**\n1. Web only - run `/test-browser`\n2. iOS only - run `/xcode-test`\n3. Both - run both commands\n4. No - skip\n```\n</offer_testing>\n#### If User Accepts Web Testing:\nSpawn a subagent to run browser tests (preserves main context):\n```\nTask general-purpose("Run /test-browser for PR #[number]. Test all affected pages, check for console errors, handle failures by creating todos and fixing.")\n```\nThe subagent will:\n1. Identify pages affected by the PR\n2. Navigate to each page and capture snapshots (using Playwright MCP or agent-browser CLI)\n3. Check for console errors\n4. Test critical interactions\n5. Pause for human verification on OAuth/email/payment flows\n6. Create P1 todos for any failures\n7. Fix and retry until all tests pass\n**Standalone:** `/test-browser [PR number]`\n#### If User Accepts iOS Testing:\nSpawn a subagent to run Xcode tests (preserves main context):\n```\nTask general-purpose("Run /xcode-test for scheme [name]. Build for simulator, install, launch, take screenshots, check for crashes.")\n```\nThe subagent will:\n1. Verify XcodeBuildMCP is installed\n2. Discover project and schemes\n3. Build for iOS Simulator\n4. Install and launch app\n5. Take screenshots of key screens\n6. Capture console logs for errors\n7. Pause for human verification (Sign in with Apple, push, IAP)\n8. Create P1 todos for any failures\n9. Fix and retry until all tests pass\n**Standalone:** `/xcode-test [scheme]`\n### Important: P1 Findings Block Merge\nAny **🔴 P1 (CRITICAL)** findings must be addressed before merging the PR. Present these prominently and ensure they\'re resolved before accepting the PR.\n```\n```\n',
      argumentHint: "[PR number or URL]",
    },
  },
  {
    name: "ghostwire:workflows:status",
    command: {
      description: "Check status of in-progress workflow or plan",
      template:
        "\n# Workflows:Status Command\nCheck the status of an in-progress workflow or plan.\n## Features\n- Shows current task progress\n- Lists completed vs pending tasks\n- Identifies blockers and open questions\n- Estimates time to completion\n- Suggests next steps\n## Integration\n- Works with `workflows:create` to track implementation progress\n- Shows background agent status\n- Provides context for `workflows:work` continuation\n<workflow-reference>\n$ARGUMENTS\n</workflow-reference>",
      argumentHint: "[workflow-reference]",
    },
  },
  {
    name: "ghostwire:workflows:stop",
    command: {
      description: "Stop all workflow continuation mechanisms",
      template:
        "\nStop all continuation mechanisms for the current session.\nThis command will:\n1. Stop the grid-todo-continuation-enforcer from automatically continuing incomplete tasks\n2. Cancel any active Ultrawork Loop\n3. Clear the ultrawork state for the current project\nAfter running this command:\n- The session will not auto-continue when idle\n- You can manually continue work when ready\n- The stop state is per-session and clears when the session ends\nUse this when you need to pause automated continuation and take manual control.\n",
    },
  },
  {
    name: "ghostwire:workflows:work",
    command: {
      description: "Execute work plans with strict preflight gates and evidence-based completion",
      template:
        "\n# Workflows:Work Command (Canonical Executor)\nExecute an approved work plan with deterministic gates and phased progression.\n## Input Document\n<input_document>\n#$ARGUMENTS\n</input_document>\n## Phase 0: Pre-Implementation Checklist Gate (Fail-Fast)\nDo not start implementation until all checks pass:\n- [ ] Plan path resolved under .ghostwire/plans/*.md\n- [ ] Tasks are present (either embedded or generated via /ghostwire:workflows:create --mode tasks)\n- [ ] Acceptance criteria are explicit and testable\n- [ ] Required checklists (security/performance/data/etc.) are reviewed when applicable\n- [ ] Dependencies and blocked tasks are understood\n- [ ] Branch strategy selected (feature branch or worktree)\nIf any gate fails:\n1. Stop execution.\n2. Report exact missing prerequisite.\n3. Provide the minimal recovery command sequence.\n## Phase 1: Setup and Branch Safety\n1. Determine current and default branch.\n2. Require explicit confirmation before committing to default branch.\n3. Prefer worktree for parallel/risky work.\n4. Create TodoWrite tasks mirroring plan order and dependencies.\n## Phase 2: Execution by Explicit Phase Order\nAlways execute in this order:\n1. Setup\n2. Foundational\n3. User Story Phases (priority order)\n4. Polish\nRules:\n- Foundational blocks all story work.\n- Respect task dependency graph from workflows:create output.\n- Mark plan checkboxes as tasks complete (`- [ ]` -> `- [x]`).\n- Keep TodoWrite synchronized with actual state.\n## Phase 3: Implementation Loop\nFor each task:\n1. Mark task in progress.\n2. Read referenced files and match existing patterns.\n3. Implement minimal change required by acceptance criteria.\n4. Write/adjust tests with deterministic validation evidence.\n5. Run targeted tests immediately.\n6. Mark task complete in both TodoWrite and plan.\n7. Evaluate incremental commit viability.\n## Phase 4: Quality and Evidence Gate\nBefore finalization:\n- [ ] All planned tasks completed or explicitly deferred with rationale\n- [ ] Acceptance criteria mapped to passing tests\n- [ ] Lint/type checks pass\n- [ ] No unresolved critical findings from analyze/checklist modes\n- [ ] Performance/security assertions validated where relevant\nIf evidence is missing, do not claim completion.\n## Phase 5: Ship and Report\n1. Create clean commits with conventional messages.\n2. Prepare PR summary with:\n- scope\n- acceptance criteria coverage\n- tests executed\n- residual risks\n3. For UI work, include before/after screenshots and URLs.\n## Completion Criteria\nA feature is complete only when:\n- All non-deferred acceptance criteria have objective passing evidence.\n- Plan status can transition to completed.\n- Remaining risks are explicitly documented.\n## Anti-Patterns to Reject\n- Starting work with unresolved prerequisites\n- Skipping foundational dependencies\n- Updating code without updating plan/task state\n- Claiming completion without test evidence\n",
      argumentHint: "[plan-path-or-name]",
    },
  },
] as const;

export const COMMAND_NAME_VALUES = [
  "ghostwire:code:format",
  "ghostwire:code:optimize",
  "ghostwire:code:refactor",
  "ghostwire:code:review",
  "ghostwire:docs:deploy-docs",
  "ghostwire:docs:feature-video",
  "ghostwire:docs:release-docs",
  "ghostwire:docs:test-browser",
  "ghostwire:git:branch",
  "ghostwire:git:cleanup",
  "ghostwire:git:merge",
  "ghostwire:git:smart-commit",
  "ghostwire:lint:ruby",
  "ghostwire:project:build",
  "ghostwire:project:constitution",
  "ghostwire:project:deploy",
  "ghostwire:project:init",
  "ghostwire:project:map",
  "ghostwire:refactor",
  "ghostwire:util:backup",
  "ghostwire:util:clean",
  "ghostwire:util:doctor",
  "ghostwire:util:restore",
  "ghostwire:work:cancel",
  "ghostwire:work:loop",
  "ghostwire:workflows:brainstorm",
  "ghostwire:workflows:complete",
  "ghostwire:workflows:create",
  "ghostwire:workflows:execute",
  "ghostwire:workflows:learnings",
  "ghostwire:workflows:plan",
  "ghostwire:workflows:review",
  "ghostwire:workflows:status",
  "ghostwire:workflows:stop",
  "ghostwire:workflows:work",
] as const;

export type CommandName = (typeof COMMAND_NAME_VALUES)[number];

export const COMMAND_NAMES = COMMAND_NAME_VALUES;
