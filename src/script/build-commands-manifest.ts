import { dirname, join } from "node:path";
import { writeFileSync } from "node:fs";
import { fileURLToPath, pathToFileURL } from "node:url";
import type { CommandDefinition } from "../execution/features/claude-code-command-loader";

const __dirname = dirname(fileURLToPath(import.meta.url));
const COMMANDS_DIR = join(__dirname, "../execution/features/commands/commands");
const OUTPUT_FILE = join(__dirname, "../execution/features/commands/commands-manifest.ts");

type CommandModule = {
  NAME?: unknown;
  COMMAND?: unknown;
};

type ManifestEntry = {
  name: string;
  command: Omit<CommandDefinition, "name">;
};

function isCommandDefinitionLike(value: unknown): value is Omit<CommandDefinition, "name"> {
  if (!value || typeof value !== "object") return false;
  const command = value as Record<string, unknown>;

  const isValidHandoff = (handoff: unknown): boolean => {
    if (!handoff || typeof handoff !== "object") return false;
    const entry = handoff as Record<string, unknown>;
    return (
      typeof entry.label === "string" &&
      typeof entry.agent === "string" &&
      typeof entry.prompt === "string" &&
      (entry.send === undefined || typeof entry.send === "boolean")
    );
  };

  const handoffs = command.handoffs;
  const hasValidHandoffs =
    handoffs === undefined || (Array.isArray(handoffs) && handoffs.every(isValidHandoff));

  return (
    (command.name === undefined || typeof command.name === "string") &&
    (command.description === undefined || typeof command.description === "string") &&
    typeof command.template === "string" &&
    (command.argumentHint === undefined || typeof command.argumentHint === "string") &&
    (command.agent === undefined || typeof command.agent === "string") &&
    (command.model === undefined || typeof command.model === "string") &&
    (command.subtask === undefined || typeof command.subtask === "boolean") &&
    hasValidHandoffs
  );
}

async function loadCommandModule(filePath: string): Promise<ManifestEntry> {
  const moduleUrl = pathToFileURL(filePath).href;
  const commandModule = (await import(moduleUrl)) as CommandModule;

  if (typeof commandModule.NAME !== "string") {
    throw new Error(`${filePath}: missing string export NAME`);
  }

  if (!isCommandDefinitionLike(commandModule.COMMAND)) {
    throw new Error(
      `${filePath}: missing export COMMAND (must include description/template/optional argumentHint)`,
    );
  }

  const rawCommand = commandModule.COMMAND as Record<string, unknown>;
  if (rawCommand.name !== undefined && rawCommand.name !== commandModule.NAME) {
    throw new Error(
      `${filePath}: COMMAND.name (${String(rawCommand.name)}) must match NAME (${commandModule.NAME})`,
    );
  }

  const normalizedCommand: Omit<CommandDefinition, "name"> = {
    ...(rawCommand.description ? { description: String(rawCommand.description) } : {}),
    template: String(rawCommand.template),
    ...(rawCommand.argumentHint ? { argumentHint: String(rawCommand.argumentHint) } : {}),
    ...(rawCommand.agent ? { agent: String(rawCommand.agent) } : {}),
    ...(rawCommand.model ? { model: String(rawCommand.model) } : {}),
    ...(typeof rawCommand.subtask === "boolean" ? { subtask: rawCommand.subtask } : {}),
    ...(rawCommand.handoffs
      ? { handoffs: rawCommand.handoffs as CommandDefinition["handoffs"] }
      : {}),
  };

  return {
    name: commandModule.NAME,
    command: normalizedCommand,
  };
}

async function discoverCommands(): Promise<ManifestEntry[]> {
  const glob = new Bun.Glob("*.ts");
  const entries: ManifestEntry[] = [];
  const seenNames = new Set<string>();

  for await (const fileName of glob.scan({ cwd: COMMANDS_DIR, absolute: true })) {
    if (fileName.endsWith(".test.ts")) continue;

    const entry = await loadCommandModule(fileName);
    if (seenNames.has(entry.name)) {
      throw new Error(`Duplicate command name discovered: ${entry.name}`);
    }

    seenNames.add(entry.name);
    entries.push(entry);
  }

  entries.sort((a, b) => a.name.localeCompare(b.name));
  return entries;
}

async function main() {
  const commands = await discoverCommands();
  const manifestJson = JSON.stringify(commands, null, 2);
  const commandNamesJson = JSON.stringify(
    commands.map((entry) => entry.name),
    null,
    2,
  );

  const output = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by src/script/build-commands-manifest.ts
// Run 'bun run src/script/build-commands-manifest.ts' to regenerate

import type { CommandDefinition } from "../claude-code-command-loader";

export type CommandManifestEntry = {
  name: string;
  command: Omit<CommandDefinition, "name">;
};

export const COMMANDS_MANIFEST: ReadonlyArray<CommandManifestEntry> = ${manifestJson} as const;

export const COMMAND_NAME_VALUES = ${commandNamesJson} as const;

export type CommandName = (typeof COMMAND_NAME_VALUES)[number];

export const COMMAND_NAMES = COMMAND_NAME_VALUES;
`;

  writeFileSync(OUTPUT_FILE, output);
  console.log(`Generated: ${OUTPUT_FILE}`);
  console.log(`Commands: ${commands.length}`);
}

main().catch((error) => {
  console.error("Failed to generate command manifest:", error);
  process.exit(1);
});
